<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识软件测试：我的入门学习记录与知识整理</title>
    <link href="/2025/09/22/%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%EF%BC%9A%E6%88%91%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <url>/2025/09/22/%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%EF%BC%9A%E6%88%91%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">测试小白的学习记录：软件测试入门知识整理</code></pre><p>大家好～我是刚踏上软件测试学习之路的小白一枚。最近刚开始系统接触测试相关知识，一边学一边把零散的知识点整理成了笔记，算是给自己初入门的测试之路留下一个小脚印，也希望能给同样刚起步的小伙伴一点点参考。<br>因为是初学，内容大概率有不够深入、甚至存在偏差的地方，特别欢迎各位前辈和同行在评论区指正、交流 —— 毕竟学习就是在不断纠错和补充中慢慢进步的～下面就是我整理的软件测试入门核心知识点，从基础概念到实际工作要点，尽量覆盖了新手会接触到的核心内容：<br>一、软件测试基础认知</p><ol><li>自动化测试脚本语言选择<br>自动化测试可选语言有很多种，比如java、Rudy，python等，这里笔者优先选择 Python，核心原因在于其特性：<ul><li>语法简单优雅<br> -工具库丰富（如 Selenium、Jmeter 均适配）<br> -代码易读性强<br> -使用灵活便捷<br> -对测试新手十分友好</li></ul></li><li>什么是软件测试？<br> 软件测试是通过人工或自动化手段运行、测定软件系统的过程，核心目的是检验软件功能是否符合需求，对比预期结果与实际结果的差异；最终目标是衡量产品是否满足客户真实需求，因此测试中需始终具备「客户思维」，站在用户视角评估产品。</li><li>软件测试的核心目的<br> 满足需求是根本：验证软件功能是否完全匹配需求文档中的定义，无遗漏、无偏差。<br> 发现缺陷是过程：核心工作是「尽早发现更多 Bug」，降低后期修复成本；因此「缺陷管理」是测试执行环节的核心 —— 需正确记录、分析、跟踪、验证系统缺陷，直至所有 Bug 被完全修复。<br> 保证质量是要点：从功能、性能、稳定性、扩展性、易用性等多维度综合评价产品，不同类型产品（如电商 App、企业后台）的评价侧重点不同。</li><li>软件测试的对象（目标产品）<br> -程序代码<br> -安装包<br> -以及涵盖与开发相关的所有文档：项目计划文档、需求文档、设计文档、用户手册等，需确保文档描述与实际产品功能一致。<br>二、测试人员全周期交付物<br>测试工作贯穿项目始终，不同阶段需输出对应的交付物，确保过程可追溯、结果可量化，具体如下：<br> 阶段交付物名称核心内容<br> 计划阶段《测试计划》明确测试范围、进度安排、资源分配（人员 &#x2F; 工具）、风险预案（如环境故障应对）<br> 计划阶段《测试方案》确定测试策略（如自动化测试比例）、工具选型（如 Jmeter 用于性能测试）<br> 设计阶段《测试用例库》结构化存储功能 &#x2F; 性能 &#x2F; 安全用例，常用 Excel 或 TestLink 管理<br> 设计阶段《需求跟踪矩阵》映射需求与测试用例，确保需求覆盖率 100%，无遗漏需求<br> 执行阶段《测试日报》每日更新用例执行进度、缺陷统计（例：“今日执行 50 条用例，发现 3 个严重缺陷”）<br> 执行阶段《缺陷报告》详细记录缺陷复现步骤、影响范围，附日志、截图（如 Jira 中的 Bug 单）<br> 收尾阶段《测试报告》总结测试结果（如用例通过率 95%）、质量评估、遗留风险（如未修复的轻微 Bug）<br> 收尾阶段《上线报告》确认版本符合上线标准，包含测试结论、应急方案（如上线后出现问题的回滚步骤）<br> 过程资产《会议纪要》记录需求评审、用例评审、缺陷评审等关键会议的决议，避免后续争议<br> 过程资产《自动化脚本》存储于 GitLab 等代码仓库，支持持续集成（CI）自动运行，提升回归效率<br>三、测试用例核心认知</li><li>什么是测试用例？<br> 测试用例是为验证特定目标（如某条程序路径、某个需求点）而编制的集合，包含测试输入、执行条件、预期结果三部分，是测试执行的核心依据（无明确用例的测试易遗漏场景）。</li><li>测试用例的基本要素<br> 必须包含 6 个核心模块：测试索引（唯一标识）、测试环境（如 Windows 10+Chrome 120）、测试输入（如账号 “test01”、密码 “123456”）、测试操作步骤（如 “点击登录按钮→输入账号→点击确定”）、预期结果（如 “成功跳转至首页”）、评价标准（如 “10 秒内加载完成即合格”）。<br>四、软件测试的 2 个关键原则<br> 1.尽早介入，降低成本：测试工作最好从需求阶段开始介入（如参与需求评审），避免需求漏洞流转到开发阶段，导致后期大量返工（后期修复缺陷的成本是需求阶段的 10 倍以上）。<br> 2.贯穿全生命周期：测试不是 “开发完才开始”，而是覆盖软件从立项到退役的全流程，具体分工如下：<br> -立项 &#x2F; 启动阶段：参与并制定初步测试计划<br> -需求调研阶段：输出《测试需求说明书》，明确测试范围<br> -设计（系统架构）阶段：编写《测试方案说明书》，搭建测试框架（如自动化测试环境）<br> -研发阶段：细化测试文档，编写测试用例与自动化脚本<br> -测试阶段：执行测试用例，生成《测试报告》《缺陷管理报告》<br> -验收阶段：协助用户完成验证，输出最终《测试报告》《验收报告》<br> -投产阶段：在生产环境做冒烟测试 + 主流程验证，确保环境可用、功能一致<br> -维护升级阶段：更新测试方案与用例，执行迭代版本测试，输出简要报告</li></ol><p>五、软件生命周期与模型</p><ol><li>软件生命周期的 6 个阶段<br> (1)需求分析与定义：通过用户调研、需求评审，明确功能规格（如核心模块）与非功能需求（如性能、安全性），输出《需求规格说明书》。<br> (2)设计阶段：<br> -架构设计：确定技术架构、模块划分、接口规范，输出《系统架构设计文档》<br> -详细设计：细化模块逻辑、数据库表结构、UI 交互，输出《详细设计说明书》<br> (3)开发实现：基于设计文档编码，遵循代码规范，完成单元测试，输出可执行程序与《单元测试报告》。<br> (4)测试阶段：执行集成测试、系统测试、验收测试，覆盖功能、性能、兼容性、安全等维度，输出《测试报告》。<br> (5)部署与维护：将软件发布至生产环境，提供技术支持并修复线上缺陷，输出《维护记录》。<br> (6)退役阶段：评估产品业务价值，停止旧版本维护，归档所有技术文档。</li><li>常见软件生命周期模型（核心特点 + 工具）<br> 模型名称                    核心特点                                                                典型工具 &#x2F; 实践<br> 瀑布模型阶段线性顺序执行（需求→设计→开发→测试→部署），需求固定后不轻易变更，强调文档驱动             Visio（绘制阶段流程图）<br> 敏捷模型迭代增量开发（2-4 周一个迭代），拆分用户故事为任务，支持持续集成（CI&#x2F;CD）                    Jira（任务管理）、Jenkins（CI）<br> V 模型    测试与开发阶段一一对应（需求分析→验收测试、设计→系统测试），强调「测试左移」                 Jira（任务跟踪）、Jenkins（CI）<br> 螺旋模型风险驱动的多轮循环（计划→风险评估→开发→测试），通过原型验证降低不确定性                         风险评估表（记录潜在风险与应对）<br>六、冒烟测试与主流程验证</li><li>冒烟测试：版本准入的「第一道关卡」<br> 定义：对软件核心功能进行快速验证，确保版本「可测」（如登录、首页加载等基础功能正常），避免后续无效测试投入（若核心功能失效，再测其他功能无意义）。<br> 有效开展要点：<br> 用例设计：仅覆盖主流程（如电商 “搜索→加购→支付”），数量控制在 10-15 条，优先级设为「高」（例：登录功能、首页导航栏跳转）。<br> 执行时机：开发提测后立即执行，环境搭建完成后 1 小时内输出结果，失败则直接打回版本。<br> 工具支持：用自动化脚本（如 Appium）执行，可配置夜间自动运行并生成报告，节省人力。<br> 结果处理：若核心功能失败（如支付接口返回 500 错误），记录阻塞缺陷并同步开发，暂停全量测试。</li><li>主流程验证：核心功能的「正向验证」<br> 定义：也称「正面测试」，通过模拟最典型、无异常的用户操作流程，验证软件核心功能是否正常运行（如电商的 “搜索→加购→下单→支付”、办公软件的 “新建文档→编辑→保存→导出”）。<br> 核心特点：<br> 测试数据：需真实有效、符合标准（如正确的手机号、格式合规的地址）。<br> 测试环境：在正常、稳定的预生产环境或测试环境中执行（避免环境问题干扰结果）。<br> 预期结果：流程必须 100% 成功，每一步操作都需达到预期输出（无报错、无卡顿）。<br>为什么要先做主流程验证？<br> 它是软件 “能用” 的最基本前提 —— 若主流程不通，再测高级功能（如个性化推荐）或异常场景（如密码错误提示）都失去意义；且开发早期修复主流程缺陷的成本最低，能保障后续测试正常推进。</li><li>主流程验证的应用场景<br> 每日构建验证：每天获取最新代码版本，先跑主流程用例，确保前一天的开发未破坏基础功能。<br> 版本转测试准入：开发提交测试前，需自行跑通主流程，确认无阻塞问题后再正式提测。<br> 上线前最后回归：软件发布前，必须完整执行一次主流程，确保用户上线后能正常使用核心功能。<br>七、软件测试核心分类<br>按不同维度，软件测试可划分为以下类别，覆盖测试全场景：<br>（一）按测试阶段划分（遵循 V 模型）<br>1.单元测试：最基础的白盒测试，核心是验证代码最小单元（函数 &#x2F; 方法 &#x2F; 类）的正确性。<br> 执行者：开发人员（自测代码）<br> 常用手段：交叉验证、双人开发、代码审查、冒烟测试<br> 目的：早发现代码逻辑错误，降低集成阶段的问题量。<br>2.集成测试：也称联调测试，验证多个模块 &#x2F; 组件之间的接口调用、数据通信是否正常。<br> 执行者：开发人员主导，测试人员辅助<br> 目的：排查模块衔接问题（如 A 模块输出的数据无法被 B 模块识别）。<br>3.系统测试：在集成好的完整系统中，全面验证功能、性能、兼容性、安全性等。<br> 包含子类型：功能测试、性能测试（压力 &#x2F; 负载测试）、兼容性测试（多系统 &#x2F; 浏览器）、安全测试（防 SQL 注入）、回归测试、冒烟测试。<br> 执行者：测试人员<br> 目的：确认系统整体符合需求，无跨模块缺陷。<br>4.验收测试：由客户 &#x2F; 用户主导的最终验证，测试人员协助在特定环境中手工测试功能、流程、UI。<br> 分两个阶段：<br> Alpha 测试：在内部受控环境中执行（如企业内网），验证核心功能。<br> Beta 测试：在真实用户环境中执行（如 App 灰度发布），收集实际使用反馈。<br> 目的：确认产品是否满足用户真实使用需求，决定是否上线。<br>（二）按测试技术划分<br>1.黑盒测试：无需了解程序内部逻辑，仅依据需求说明书验证功能是否符合预期（站在用户视角）。<br> 包含类型：功能测试、验收测试、UI 测试<br> 常用方法：等价类划分、边界值分析、因果图、错误推断法。<br>2.白盒测试：需了解程序内部逻辑（如代码结构、分支路径），设计用例覆盖关键路径。<br> 常用方法：语句覆盖、条件覆盖、条件组合覆盖、路径覆盖<br> 执行者：以开发人员为主（单元测试、代码审查）。<br>3.灰盒测试：融合黑盒与白盒思路 —— 既关注输入输出的正确性，也关注部分内部逻辑（如接口调用逻辑），适合接口测试、集成测试。<br>（三）按测试手段划分<br>1.功能测试（手工测试）：人工执行测试用例，验证功能是否符合预期，整理结果、管理缺陷。<br> 适用场景：探索性测试（无明确用例，靠经验挖掘问题）、易用性测试（评估操作流畅度）、短期小需求测试。<br> 核心特点：灵活、能发现自动化脚本覆盖不到的细节问题，但效率低、重复性差。<br>2.自动化测试：用工具（Selenium、Appium）或脚本实现测试自动化，自动执行用例、对比结果。<br> 优点：速度快、可重复执行、适合大量重复场景（如回归测试、性能测试）。<br> 缺点：开发与维护脚本的成本高（需懂代码），无法完全替代手工测试（如 UI 美观度、易用性评估）。<br> 常见工具：Web 自动化用 Selenium、App 自动化用 Appium、性能测试用 Jmeter。</li></ol><p>以上就是我现阶段整理的全部内容啦～因为是刚入门，对很多概念的理解可能还比较浅，比如自动化测试的脚本设计、性能测试的指标分析这些深层内容，还在慢慢学习中。<br>如果大家发现哪里有错误，或者有更通俗的解释、更实用的技巧，特别欢迎在评论区告诉我～也希望和同样在学测试的小伙伴一起交流，互相督促进步～</p>]]></content>
    
    
    
    <tags>
      
      <tag>-python -软件测试 -测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的成长之路</title>
    <link href="/2025/09/21/hello-world/"/>
    <url>/2025/09/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
